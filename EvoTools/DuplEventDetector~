#!/usr/bin/perl

=head1 NAME

 DuplEventDetector
 Pipeline to detect duplication events based in Ks profiles

=cut

our $VERSION = '0.1';
$VERSION = eval $VERSION;

=head1 SYPNOSIS

 DuplEventDetector [-h] [-v] -f <cdnafastafile> [-t <threads>] [-o <output>]
                             [-B <blat_arguments>] [-i <min_identity>]
                             [-l <min_length>] [-c <min_coverage>] 
                             [-a <annotation_gff>] [-b <min_geneblock_size>]
                             [-g <max_genegap>] [-d <min_block_distance>]
                             [-M <muscle_arguments>] [-P <paml_arguments>]
                             [-K] [-V]

=head2 I<Flags:>

=over


=item -f

B<cdnafastafile>                input cDNA fasta file (mandatory)

=item -t

B<threads>                      number of threads (2 by default)

=item -o

B<output>                       output basename (duplrun+date. by default)

=item -B

B<blat_arguments>               blat arguments (example -B '-fine -minScore 20')

=item -i

B<min_identity>                 min. identity to filter a blat hit

=item -l

B<min_length>                   min. lenght to filter a blat hit

=item -c

B<min_coverage>                 min. coverage to filter a blat hit

=item -a

B<gff_file>                     gff annotation file with gene positions

=item -b

B<min_gene_block>               min. number of gene per block

=item -g

B<max_gene_gap>                 max. number of gene gaps per block

=item -d

B<min_distance>                 min. distance (Kb) between blocks

=item -M

B<muscle_arguments>             muscle arguments (ex. -M '-maxiters 1 -diags')

=item -P

B<PAML_arguments>               PAML arguments.

=item -K

B<keep_all_files>               keep the intermediate files

=item -V

B<be_verbose>                   be verbose

=item -h

B<help>                         print the help

=item -v

B<version>                      print version

=back

=cut

=head1 DESCRIPTION

 DuplEventDetector is an analysis pipeline designed to calculate the
 Ks of duplicates genes from a fasta file and represent them grafically
 to find possible Whole Genome Duplication (WGD) events.

 This pipeline involves several steps:

 1) Paralog/Homeolog search using a reciprocal Blat of the protein sequences.

    The blat default arguments can be modified using the -B option
    (example -B '-fine -minScore=50') 
  
    This homolog search is filtered based in two parameters:
      -i <min_identity>
      -l <min_length>
      -c <min_coverage>

    Additionally synthenic block information can be used to parse the 
    the paralog/homoeolog genes. This could be supplied as a gff3 file
    with the locations of each gene (-a <gff_file>). 
    In this case three parameters could be used to define a synthenic block:

      -b <min_gene_block>, min. number of genes to define a synthenic block.
      -g <max_gene_gap>, max. number of genes to define a gap.
      
    For example to detect the following microsynthenic block:
               
      ---A1---B1-B2---C1---D1-----
         ||   ||//         ||
      ---A2---B3-----------D2-----

    B1-B2 will be identified as a tandem duplication.
    The pairs A1-A2, B1-B3, D1-D2 will define a block with 3 hits.
    C1 will be one gap in the block.

    So this block will be detected as -b 3 -g 1 or lower b values and higher
    g values (still g < b).
    In this example 4 pairs will be returned (A1-A2, B1-B3, B2-B3 and D1-D2).
    The pair B1-B2 will return as a tandem duplication event (TDE).

    Additionally tandem duplications can be defined as single gene tandem
    duplication (SGTD) or a multiple gene tandem duplication (MGTD). A
    multiple gene tandem duplication will be defined by blocks in the same
    chromosome than doesnt meet the -d <min_block_distance requeriment>.

    For example:

      -----A1---B1---C1---D1---|20Kb|---A2---B2---D2-----      
      
      if -b 3 -g 1 -d 10 the pairs A1-A2, B1-B2, D1-D2 will be defined as WGD
      if -b 3 -g 1 -d 50 the pairs A1-A2, B1-B2, D1-D2 will be defined as MGTD

 2) Sequence alignment using Muscle.

    The muscle arguments can be modified using the -M option.
    (-M '-maxiters')

 3) Ks, Kn and Ks/Kn calculation for each of the pair using PAML.

 4) Analysis of the Ks values using R.


=cut

=head1 AUTHORS

  Aureliano Bombarely Gomez.
  (ab782@cornell.edu).

=cut

=head1 METHODS

 DuplEventDetector

=cut


use strict;
use warnings;
use autodie;

use Config;
use threads;

use File::Basename;
use File::Spec;
use File::Path qw(remove_tree);
use Getopt::Std;
use Math::BigFloat;
use Bio::SeqIO;

our ($opt_f, $opt_t, $opt_o, $opt_B, $opt_i, $opt_l, $opt_c, $opt_a, $opt_b,
     $opt_g, $opt_d, $opt_M, $opt_P, $opt_K, $opt_V, $opt_v, $opt_h);
getopts("f:t:o:B:i:l:c:a:b:g:d:M:P:KVvh");

$Config{useithreads} or 
    die('THREAD ERROR: Recompile Perl with threads to run this program.');

if (!$opt_f && !$opt_t && !$opt_o && !$opt_B && !$opt_i && !$opt_l && !$opt_c 
    && !$opt_a && !$opt_b && !$opt_g && !$opt_d && !$opt_M && !$opt_P 
    && !$opt_K && !$opt_V && !$opt_v && !$opt_h) {
    print STDERR "There are n\'t any tags. Print help\n\n";
    help();
}
elsif ($opt_h) {
    help();
}
elsif ($opt_v) {
    print STDERR "\nMultiThreadBlat version: $VERSION\n\n";
    exit(1);
}

my $date = `date`;
chomp($date);

print STDERR "\n\n#########################################################\n";
print STDERR "## DuplEventDetector version:$VERSION                      ##\n";
print STDERR "## $date                        ##\n";
print STDERR "#########################################################\n\n";

## First argument checking

print_header("0) Argument Validation");

my $fasta = $opt_f ||
    die("ERROR: Mandatory argument -f <cds_fastafile> was not supplied");

my @ltime = localtime(time);
$ltime[5] += 1900;

my $outbase = $opt_o || 'duplrun' . join("_", reverse(@ltime[0..5]));

## Check blat arguments

our $blat_exec = $ENV{BLAT_EXEC} || 'blat';

my $blat_h = `$blat_exec`;
my @blatopt = ();

unless (defined $blat_h) {
    die("ERROR: No blat executable was accessible.More info at -h argument.\n");
}
else {
    print STDERR "\tBlat executable:\tOk\n";

    ## Use the blat help to retrieve the options and check the arguments

    
    ## Check if exists type or nohead. Overwrite them

    my ($nohead, $pslout) = (0, 0);

    if ($opt_B) {

	my @blathelp = split(/\n/, $blat_h);
	my %blat_args = ();
	my $opt = 0;

	foreach my $blat_hline (@blathelp) {
	    
	    if ($blat_hline =~ /options:/) {
		$opt = 1;
	    }
	    	    
	    if ($opt == 1 && $blat_hline =~ m/(\-\w+)=(.+?)\s+/) {
		$blat_args{$1} = $2;
	    }
	    elsif ($opt == 1 && $blat_hline =~ m/(\-\w+?)\s+/) {
		$blat_args{$1} = 1;
	    }
	}

	my @blat_args = split(/ /, $opt_B);

	foreach my $blat_arg (@blat_args) {
	    
	    if ($blat_arg =~ m/^-noHead$/) {

		$nohead = 1;
	    }
	    elsif ($blat_arg =~ m/^-out=(.+)$/) {
	    
		my $fout = $1;
		if ($fout !~ m/^psl$/) {
		
		    print STDERR "\tOverwritting blat out to -out=psl\n\n";
		    $blat_arg = '-out=psl';
		}	
		$pslout = 1;		
	    }
	    elsif ($blat_arg =~ m/^(.+?)=(.+)$/) {

		unless (exists $blat_args{$1}) {
		    die("ERROR: $1 is not a blat valid option.\n");
		}
	    }
	    else {
		
		unless (exists $blat_args{$blat_arg}) {
		    die("ERROR: $blat_arg is not a blat valid option.\n");
		}
		if ($blat_args{$blat_arg} ne 1) {
		    die("ERROR: $blat_arg doesnt have format $blat_arg=val.\n");
		}
	    }

	    push @blatopt, $blat_arg;
	}   
    
	print STDERR "\tBlat options:\t\tOk\n";
    }
    else {
	print STDERR "\tBlat options:\t\tDefault\n";
    }

    if ($nohead == 0) {
	
	push @blatopt, '-noHead';
    }
    if ($pslout == 0) {
	
	push @blatopt, '-out=psl';
    }
}

my $threads = $opt_t || 2;
if ($threads !~ m/^\d+$/) {
    die("ERROR: -t <threads> is not an integer.\n");
}
else {
    print STDERR "\tThreads:\t\t$threads\n";
}

## Blat filter check

my $min_ident = $opt_i || 70;
if ($min_ident !~ m/^\d+$/) {

    die("ERROR: -i <min_identity> doesnt have a numeric value ($min_ident).\n");
}
else {

    print STDERR "\n\tMin. blat hit identity:\t$min_ident\n";
}

my $min_length = $opt_l || 100;
if ($min_length !~ m/^\d+$/) {

    die("ERROR: -l <min_length> doesn't have a numeric value ($min_length).\n");
}
else {

    print STDERR "\n\tMin. blat hit length:\t$min_length\n";
}

my $min_cov = $opt_c || 75;
if ($min_ident !~ m/^\d+$/) {

    die("ERROR: -c <min_coverage> doesn't have a numeric value ($min_cov).\n");
}
else {

    print STDERR "\n\tMin. blat hit coverage:\t$min_cov\n";
}



## Create the dir ############################################################

mkdir($outbase);


#### Run blat ################################################################

print_header("1) Running Blat");

my $blatdir =  File::Spec->catfile($outbase, '01_blatsearch');
mkdir($blatdir);

my $batchdir = File::Spec->catfile($blatdir, 'dbbatches');
mkdir($batchdir);

## The program will divide the sequence set based in the number of
## threads. It is a self blat.

print STDERR "\n\n1) Creating fasta sequence batches\n\n";

my @subfastalist = create_batches($batchdir, $fasta, $threads);

print STDERR "\n\n2) Running the batch jobs\n\n";

## It will divide the jobs in packages
## based in the number of threads
## It will be as many jobs in a package as threads have been especified.

my $max_j = scalar(@subfastalist);

my @packages = ();
my @jobs = ();
my @outfiles = ();

my ($j, $v) = (0, 0);

foreach my $dbfile (@subfastalist) {
    
    my $outbase = basename($dbfile).'.blat.'.basename($fasta).'.job'.$j;
    my $outfile = File::Spec->catfile($batchdir, $outbase);
    my @files = ($dbfile, $fasta, $outfile);
    push @jobs, \@files;
    push @outfiles, $outfile;

    $j++;

    if ($v + 1 == $max_j || $j == $threads) {        ## It is the last job

	my @pack_jobs = @jobs;
	push @packages, \@pack_jobs;
	$j = 0;
	@jobs = ();
    }
    $v++;
}


my $pcks = scalar(@packages);
print STDERR "\tBatches have been organized in $pcks packages and $v jobs\n";

my $j_exec = 0;
my $p = 0;

foreach my $pack (@packages) {

    $p++;
    my @exjobs = @{$pack};
    my ($n, $j_run) = (0, 0);
    my @th_procs = ();

    my $all_j = scalar(@exjobs);
    print STDERR "\n\tRunning package $p ($threads threads)\n";

    while($n < $threads && $j_exec <= $v && $j_run < $all_j)  {	

	my @runblatopt = @blatopt;
	$j_run++;
	my @jobfiles = @{$exjobs[$n]};
	my $th_proc = threads->create(\&run_batchblat, @jobfiles, \@runblatopt);
	push @th_procs, $th_proc;
	$n++;
    }

    foreach my $th (@th_procs) {
	my $th_id = $th->tid();
	my $th_res = $th->join();

	unless (defined($th_res)) {
	    warning("\tExecution error for thread $th_id\n");
	    my $error = $th->error();
	    print "\n===== ERROR $th_id =====\n$error\n===================\n";
	}
	$j_exec++;
    }
}

print STDERR "\t$j_exec jobs have been executed in $p packages.\n";

print STDERR "\n\n4) Joining the batch jobs results\n\n";

my $f_outfile = File::Spec->catfile($blatdir, 'blatresult.psl');

## It will simply concatenate the files.

my $cat_cmd = 'cat ' . join(" ", @outfiles) . " > $f_outfile";
system($cat_cmd);

print STDERR "\tOutfile:\t$f_outfile\n";

unless ($opt_K) {

    remove_tree($batchdir, { verbose => 0, safe => 1 });
    print STDERR "\tBatch files have been removed\n";
}
else {
    print STDERR "\tKeep batch files:\tEnabled\n";
    print STDERR "\tBatch files stored at: $batchdir\n";
}

###############################################################################
## Parse and filter the blat file
###############################################################################

print_header("2) Parsing Blat Output");

my %clusters = parse_blat($f_outfile, $min_ident, $min_length, $min_cov);






$date = `date`;
chomp($date);
print STDERR "\n\n#########################################################\n";
print STDERR "## End of the DuplEventDetector execution              ##\n";
print STDERR "## $date                        ##\n";
print STDERR "#########################################################\n\n";

=head2 help

  Usage: help()
  Desc: print help of this script
  Ret: none
  Args: none
  Side_Effects: exit of the script
  Example: if (!@ARGV) {
               help();
           }

=cut

sub help {
  print STDERR <<EOF;
  $0:

    Description:
      
     

    Note: 
       
    

    Usage:
      
  
    Flags:
     
     -h <help>                  print this help
     -v <version>               print the script version

EOF
exit (1);
}

=head2 print_header

  Usage: print_head("Message");
  Desc: print a section head
  Ret: None
  Args: Message to print in the header
  Side_Effects: None
  Example: print_head("Step1: This is a test");

=cut

sub print_header {
    my $message = shift;

    my $date = `date`;
    chomp($date);

    print STDERR "\n";
    print STDERR "============================================================";
    print STDERR "\n $message ($date)\n";
    print STDERR "============================================================";
    print STDERR "\n\n";
}


=head2 create_batches

  Usage: my @filelist = create_batches($dir, $seqfile, $batches)
  Desc: create batch for a sequence file
  Ret: an array with the list of subfiles
  Args: $dir, dir to create the files
        $seqfile, file to split
        $batches, number of batches to create.
  Side_Effects: die of something is wrong
  Example: my @qufilelist = create_batches($batchdir, $quseq, $qubch);

=cut

sub create_batches {

    my $dir = shift || 
	die("ERROR: No dir was supplied to create_batches function.\n");
    my $seqfile = shift ||
	die("ERROR: No seqfile was supplied to create_batches function.\n");
    my $batches = shift ||
	die("ERROR: No batches was supplied to create_batches function.\n");

    ## Check that the file exists with Bioperl and count seq

    my $seq_io = Bio::SeqIO->new( -file => $seqfile, -format => 'fasta');
    my $seqcount = `grep -c '^>' $seqfile`;
    chomp($seqcount);

    ## Calculate the size of the batch

    my $batch_size = Math::BigFloat->new($seqcount / $batches)->bfround(0);
    print STDERR "\tBatch size:\t$batch_size sequences\n";

    ## Declare variables used in the batch

    my @seq_batch = ();

    if ($batches == 1) {

	push @seq_batch, $seqfile;
	print STDERR "\tNo batch requested for $seqfile\n";
    }
    else {

	my ($s, $b) = (1, 1);
	my $basenm = basename($seqfile);
	
	my $outseq_io = '';

	while(my $seq_o = $seq_io->next_seq() ) {

	    ## Three posibilities:
	    ## 1) SeqN == 1, create a new file
	    ## 2) SeqN < BatchSize, add sequences to the batch
	    ## 3) SeqN == BatchSize, add the last sequence if is not the last
	    ##    batch and set SeqN to zero to create a new file in th next
	    ##    iteraction.

	    
	    if ($s == 1 ) {
	
		my $newseqfile = File::Spec->catfile($dir, $basenm .'_sub'. $b);
		$outseq_io = Bio::SeqIO->new( 
		    -file   => ">$newseqfile", 
		    -format => 'fasta'
		    );
		$outseq_io->write_seq($seq_o);
		$s++;
		
		push @seq_batch, $newseqfile;
		print STDERR "\tCreated file batch: $newseqfile\n";

		if ($batch_size == 1) {
		    $s = 1;
		    $b++;
		}
	    }
	    elsif ($s < $batch_size) {
		
		$outseq_io->write_seq($seq_o);
		$s++;
	    }
	    else {
		
		$outseq_io->write_seq($seq_o);
		
		if ($b < $batches) {
		    $s = 1;
		}
		$b++;
	    }
	}
    }
    return @seq_batch;    
}

=head2 run_batchblat

  Usage: run_batchblat($dbfile, $qufile, $oufile, $arguments);
  Desc: run blat with the specified parameters
  Ret: nothing
  Args: $dbfile, database filename
        $qufile, query filename
        $outfile, name for the outputfile
        $arguments, as string separated by commas
  Side_Effects: die of something is wrong
  Example: run_batchblat($dbfile, $qufile, $oufile, $arguments);

=cut

sub run_batchblat {
    
    my $dbfile = shift ||
	die("ERROR: No dbfile was supplied to run_batchblat");
    my $qufile = shift ||
	die("ERROR: No qufile was supplied to run_batchblat");
    my $outfile = shift ||
	die("ERROR: No outfile was supplied to run_batchblat");
    my $argaref = shift;

    my $cmd = "$blat_exec $dbfile $qufile";
    
    if (defined $argaref && ref($argaref) eq 'ARRAY') {

	my $blatopts = join(" ", @{$argaref});
	$cmd .= " $blatopts";
    }
    
    $cmd .= " $outfile";
    $cmd .= " 1> " . $outfile . ".runblat.log";

    #print STDERR "\tRunning: $cmd\n";
    system($cmd);
 
    return 1;
}


=head2 parse_blat

  Usage: my %clusters = parse_blat($f_outfile, $ident, $length, $cov);
  Desc: Parse the blat output and returns clusters
  Ret: A hash with key=$seqid, value=$clusterid
  Args: $f_outfile, a filename of the blat result file (psl)
        $ident, a min. identity to accept a hit
        $length, a min. length to accept a hit
        $cov, a min coverage to accespt a hit
  Side_Effects: die of something is wrong
  Example: my %clusters = parse_blat($f_outfile, $ident, $length, $cov);

=cut

sub parse_blat {
    my $input = shift ||
	die("ERROR: No input file was supplied to parse_blat.\n");
    my $ident = shift ||
	die("ERROR: No min. identity hit was supplied to parse_blat.\n");
    my $length = shift ||
	die("ERROR: No min. length hit was supplied to parse_blat.\n");
    my $cover = shift ||
	die("ERROR: No min. coverage hit was supplied to parse_blat.\n");

    open my $ifh, '<', $input;
    my $L = `grep '^[0-9]' $input | wc -l`;
    chomp($L);

    my ($l, $c, $members) = (0, 0, 0);
    my %cls = ();
    my $parsesign = 0;

    while(<$ifh>) {
    
	chomp($_);
	$l++;

	if ($opt_V) {
	
	    print STDERR "\tParsing line $l of $L        \r";
	}
		
	my @data = split(/\t/, $_);
	
	## Ignore selfhits

	if ($data[9] ne $data[13]) {
	    
	    ## get the filtering options
	    my $hlength = $data[0] + $data[1];
	    my $seq1cov = $data[0] * 100 / $data[10];
	    my $seq2cov = $data[0] * 100 / $data[14];
	    my $hident = $data[0] * 100 / $hlength;
	    
	    if ($hlength >= $length && $hident >= $ident) {
		
		if ($seq1cov >= $cover && $seq2cov >= $cover) {
		    
		    ## That will be selected;

		    if (exists $cls{$data[9]} && exists $cls{$data[13]}) {
			
			## Just ignore
		    }
		    elsif (exists $cls{$data[9]}) {
			
			$cls{$data[13]} = $cls{$data[9]};
			$members++;
		    }
		    elsif (exists $cls{$data[13]}) {
			
			$cls{$data[9]} = $cls{$data[13]};
			$members++;
		    }
		    else {
			
			$c++;
			$members += 2;
			$cls{$data[13]} = $c;
			$cls{$data[9]} = $c;
		    }
		}		
	    }		    		
	}
    }

    ## At this point all the sequences should be in clusters

    print STDERR "\n\n\tBlat result file parsed\n";
    ;
    print STDERR "\n\tTotal Clusters:\t$c\n";
    print STDERR "\tMembers in clusters:\t$members\n";

    return %cls;
}
